{
    "collab_server" : "",
    "contents" : "---\ntitle: \"FigShare\"\noutput: html_document\n---\n\n```{r, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## Figshare Overview\n\n[FigShare](http:www.figshare.com) is an extremely popular free to access data repository capable of generating DOI for deposited data, and supports versioning. It is therefore a useful option for researchers with data sets that will grow. Deposits can be made entirely private or embargoed as required by individual projects, but a DOI can be reserved before publishing the dataset making it easier to write associated materials and publications against the dataset.\n\nDeposits include a small range of standard meta-data attributes, but a long-form description can be provided and multiple files may be attached to a single deposit. The example used in this guide provides a useful overview of what is possible with figshare - [\"Investigation into the number of desktop items on University staff computers, broken down by department and operating system\"](https://figshare.com/articles/Investigation_into_the_number_of_desktop_items_on_University_staff_computers_broken_down_by_department_and_operating_system_/3425729).\n\nFiles attached to public deposits like the one used in this guide can be accessed directly via a URL or the Figshare API - https://ndownloader.figshare.com/files/5449739\n\n### Figshare API Access with rfigshare\n\nThe <a href=\"https://github.com/ropensci/rfigshare\">rfigshare</a> library provides access to the Figshare API, allowing the following operations to be performed:\n\n- Read deposit meta data\n- Download files attached to deposits\n- Modify and add files existing deposits\n- Create new deposits\n\nIn order to use the library it must be loaded and authenticated against your Figshare account - note that this will launch a browser window.\n\n```{r}\nlibrary(rfigshare)\nfs_auth()\n```\n\nFor shiny apps it is necessary to locally store the authentication token returned by `fs_auth`, this is easily achieved by copying the `.httr-oauth` saved to the working directory by `fs_auth` into the shiny app directory. It is important to remember that the `.httr-oauth` file contains private information that would allow others access to your Figshare account, ensure to include this file in your `.gitignore` file if you are using git.\n\n### Browsing Figshare Deposits\n\nIt is possible to browse the entirety of Figshare through the `fig_browse` function, which returns a list of all deposits against your account.\n\n```{r}\nmy_figshare_deposits <- fs_browse(mine = TRUE)\n```\n\nThe following utility function allows us to extract the `article_id`, `title` and `published_date` from the `my_figshare_deposits` object.\n\n```{r, eval=TRUE}\nextract_data <- lapply(my_figshare_deposits, function(x){\n  \n  col_indices <- which(names(x) %in% c(\"article_id\", \"title\",\"published_date\"))\n  \n  x[col_indices]\n  \n})\nknitr::kable(as.data.frame(extract_data))\n```\n\nAll Figshare deposits are assigned an `article_id` which forms part of the DOI, consider the DOI for our example dataset - https://dx.doi.org/10.6084/m9.figshare.3425729.v3 - the `artice_id` is 3425729 and details about this article can be obtained via `fs_details`\n\n```{r, eval=TRUE}\narticle_details <- fs_details(article_id = 3425729)\narticle_details$title\n```\n\nIndividual files attached to a Figshare article are detailed within a list stored against `article_details$files`.\n\n```{r}\nknitr::knitr(as.data.frame(lapply(article_details$files,function(x){x[c(\"name\",\"download_url\")]})))\n```\n\n### Reading Files\n\nPublically shared files in Figshare deposits are directly accessible via their ndownloader.figshare.com address, the file we're interested in is https://ndownloader.figshare.com/files/5360960. As with any web-hosted file, this can easily be downloaded into the working directory with the `download.file` function and then imported via `read.csv`\n\n```{r}\ndownload.file(url = \"https://ndownloader.figshare.com/files/5360960\", destfile = \"desktop_items.csv\")\nknitr::kable(head(read.csv(\"desktop_items.csv\")))\n```\n\nPublic data files cannot be deleted or otherwise removed from Figshare (without extraudinary circumstances), it is therefore unimportant to test for whether a file exists or not. However, there may be situations where Figshares server are temporarily unavailable\n\n```{r}\nsuppressWarnings({\n  download_try <- try(download.file(url = \"https://ndownloader.figshare.com/files/non-existant-url\", destfile = \"desktop_items.csv\"))\nif(class(download_try) == \"try-error\"){\n  \"Download Failed\"\n}})\n```\n\n### Local Caching of Files\n\nIn this instance, caching means keeping a local copy of a dataset that is \"replaced\" if the remote file is updated. This provides two advantages, if Figshare is not available when the code is run the local copy provides a backup solution and it ensures the data is always as up to date as possible. In the case of a shiny app this requires persistant data stores, there is a fairly technical description of persistant data storage in shiny apps available <a href=http://shiny.rstudio.com/articles/persistent-data-storage.html>here</a> that is used as the template for the caching mechanism this tutorial describes. The procedure depends on the following paradigm:\n\n```\n\"you save a new file every time there is new data\"\n```\n\nFigshare provides a versioning system for deposits, the https://ndownloader.figshare.com/files/5360960 URL will always provide the most up-to-date version of the datafile and public files cannot be deleted. This informs our procedure for efficiently caching the files:\n\n- Is external file version number greater than the local version?\n- FALSE: Import local file\n- TRUE: Download remote file to local directory and import\n\nThis procedure does not attempt to account for deltas and simply downloads a new copy of the remote file whenever it is updated - this could result in a large number of files within the shiny app. To account for this, the following step is added to the procedure:\n\n- If more than 3 local files exist, purge the oldest 2\n\n#### Local Script\n\nWhen first running the script generate a uniquely named file and store the version number of the dataset:\n\n```{r}\ntarget_article_id <- 3425729\ntarget_ndownloader_link <- \"https://ndownloader.figshare.com/files/5360960\"\ninitial_version_number <- fs_details(article_id = target_article_id)$version\nwrite(downloaded_version_number, file = \"initial_version_number.txt\")\n```\n\nDefine a function for creating unique file names based on `Sys.time` and a single random real number from `runif`. This is designed to account for multiple users of the shiny app attempting to create new files at exactly the same time, there is an extremely low probability of naming conflicts using this convention.\n\n```{r}\nunique_name_fn <- function(){digest::digest(paste0(as.integer(Sys.time()),runif(1)))}\n```\n\n\nOur algorithm\n\n```{r}\nexternal_version <- fs_details(article_id = target_article_id)$version\nlocal_version <- read.table(file = \"initial_version_number.txt\")[1,]\nwrite(external_version, file = paste0(f_name,\"_downloaded_version_number\",external_version,\".txt\"))\nexternal_version\n\nany(grepl(pattern = \"user[_]downloaded\", list.files()))\n\nif(external_version > local_version){\n  \n  f_name <- unique_name_fn()\n  \n  download.file(url = \"https://ndownloader.figshare.com/files/5360960\", \n                destfile = paste0(f_name,\"_user_downloaded.csv\"))\n  \n  write(external_version, file = paste0(f_name,\"_downloaded_version_number_\",external_version,\".txt\"))\n}\n\nany(grepl(pattern = \"user[_]downloaded\", list.files()))\n\n## Get version and downloaded file names\nuser_downloaded_version_files <- list.files()[grepl(pattern = \"downloaded[_]version[_]number\", list.files())]\nuser_downloaded_files <- list.files()[grepl(pattern = \"user[_]downloaded\", list.files())]\n## Import files and get the unique code for the most up to date version\nuser_downloaded_version <- unlist(lapply(user_downloaded_versions, function(x){read.table(x)[1,]}))\nmost_upto_date <- gsub( \"[_].*$\", \"\", user_downloaded_version_files[which.max(user_downloaded_version)])\n## Return filename\nuser_downloaded_files[grepl(pattern = most_upto_date, x = user_downloaded_files)]\n\n\n```\n\nACTUAL SOLUTION:\n\n```{r}\nif (any(grepl(pattern = \"user[_]downloaded\", list.files()))) {\n  ## User downloaded files exist\n  \n} else {\n  ## Never downloaded a new version\n  \n}\n```\n\n",
    "created" : 1469106938051.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "547461167",
    "id" : "867A5307",
    "lastKnownWriteTime" : 1469195121,
    "last_content_update" : 1469195121079,
    "path" : "~/Github/Live-Data_Scripts-and-Templates/Repositories/Figshare/index.Rmd",
    "project_path" : "index.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}